#!/usr/bin/env python3

# Copyright (C) 2012-2019
#
# * Volker Diels-Grabsch <v@njh.eu>
# * art0int <zvn_mail@mail.ru>
# * Matthew Fearnley (matthew.w.fearnley@gmail.com)
# * rhn <gihu.rhn@porcupinefactory.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Copies files from a remote device"""

import hashlib
import os
import struct
import subprocess
import sys

from pathlib import Path


remote_script = open('remote_script.py').read()

class IOCounter:
    def __init__(self, in_stream, out_stream):
        self.in_stream = in_stream
        self.out_stream = out_stream
        self.in_total = 0
        self.out_total = 0
    def read(self, size=None):
        if size is None:
            s = self.in_stream.read()
        else:
            s = self.in_stream.read(size)
        self.in_total += len(s)
        return s
    def write(self, s):
        self.out_stream.write(s)
        self.out_total += len(s)
        self.out_stream.flush()


def bscp(local_filename, remote_host, remote_filename, blocksize, hashname, compress=False):
    hash_total = hashlib.new(hashname)
    with open(local_filename, 'rb+') as f:
        f.seek(0, os.SEEK_END)
        size = f.tell()
        f.seek(0)

        remote_command = 'python3 -c "%s"' % (remote_script,)
        command = ('ssh', '-C', '--', remote_host, remote_command)
        p = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)

        bremote_filename = remote_filename.encode('utf-8')
        bhashname = hashname.encode('utf-8')
        io = IOCounter(p.stdout, p.stdin)

        io.write(struct.pack('<QQQQ', size, blocksize, len(bremote_filename), len(bhashname)))
        io.write(bremote_filename)
        io.write(bhashname)

        sanity_digest = hashlib.new(hashname, bremote_filename).digest()
        remote_digest = io.read(len(sanity_digest))
        if remote_digest != sanity_digest:
            raise RuntimeError('Remote script failed to execute properly')
            
        io.write(b'go')

        (remote_size,) = struct.unpack('<Q', io.read(8))
        print('Detected {} bytes'.format(remote_size))
        if Path(local_filename).is_block_device():
            if remote_size > size:
                raise ValueError("Source data can't fit on the local device: {} < {} bytes".format(size, remote_size))
        else:
            if remote_size < size:
                raise ValueError('Destination file already bigger than source device: {} > {} bytes'.format(size, remote_size))
            f.truncate(remote_size)
        
        # Calculate number of blocks, including the last block which may be smaller
        blockcount = int((remote_size + blocksize - 1) / blocksize)

        for i in range(blockcount):
            f.seek(i * blocksize)
            # last read should be smaller if the destination is bigger than the source (block device)
            read_size = min(remote_size - i * blocksize, blocksize)
            block = f.read(read_size)
            local_digest = hashlib.new(hashname, block).digest()
            header = io.read(1)
            if header != b'd':
                raise RuntimeError("Not a digest: {!r}".format(header))
            remote_digest = io.read(hash_total.digest_size)
            if remote_digest != local_digest:
                print('X', end='')
                sys.stdout.flush()
                io.write(b'send')
                header = io.read(1)
                if header != b'b':
                    raise RuntimeError("Not a block: %s" % header)
                block = io.read(blocksize)
                hash_total.update(block)
                remote_total = io.read(hash_total.digest_size)
                if remote_total != hash_total.digest():
                    print(i, blockcount)
                    raise RuntimeError("Total checksum mismatch")
                f.seek(i * blocksize)
                f.write(block)
            else:
                print('.', end='')
                sys.stdout.flush()
                io.write(b'done')
                hash_total.update(block)
        header = io.read(1)
        if header != b't':
            raise RuntimeError("Not a total digest: %s" % header)
        remote_digest_total = io.read()
        p.stdin.close()
        p.wait()
        if remote_digest_total != hash_total.digest():
            raise RuntimeError('Checksum mismatch after transfer')
    return (io.in_total, io.out_total, remote_size)

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--hash_name', choices=['sha1'], default='sha1',
                        help='Hash function name')
    parser.add_argument('--block_size', '-b', type=int, default=64*1024,
                        help='Block size')
    parser.add_argument('--compress', '-c', action='store_true')
    parser.add_argument('src', help='Source block device (remote)')
    parser.add_argument('dest', help='Destination file (local)')
    args = parser.parse_args()

    (remote_host, remote_filename) = args.src.split(':')

    (in_total, out_total, size) = bscp(args.dest, remote_host, remote_filename, args.block_size, args.hash_name, compress=args.compress)
    speedup = size * 1.0 / (in_total + out_total)
    sys.stderr.write('\nin=%i out=%i size=%i speedup=%.2f\n' % (in_total, out_total, size, speedup))
