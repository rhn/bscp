#!/usr/bin/env python3

# Copyright (C) 2012-2019
#
# * Volker Diels-Grabsch <v@njh.eu>
# * art0int <zvn_mail@mail.ru>
# * Matthew Fearnley (matthew.w.fearnley@gmail.com)
# * rhn <gihu.rhn@porcupinefactory.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""Copies files from a remote device"""

import hashlib
import struct
import subprocess
import sys

remote_script = open('remote_script.py').read()

class IOCounter:
    def __init__(self, in_stream, out_stream):
        self.in_stream = in_stream
        self.out_stream = out_stream
        self.in_total = 0
        self.out_total = 0
    def read(self, size=None):
        if size is None:
            s = self.in_stream.read()
        else:
            s = self.in_stream.read(size)
        self.in_total += len(s)
        return s
    def write(self, s):
        self.out_stream.write(s)
        self.out_total += len(s)
        self.out_stream.flush()


def bscp(local_filename, remote_host, remote_filename, blocksize, hashname, to_remote=True):
    hash_total = hashlib.new(hashname)
    with open(local_filename, 'rb+') as f:
        f.seek(0, 2)
        size = f.tell()
        f.seek(0)

        remote_command = 'python3 -c "%s"' % (remote_script,)
        command = ('ssh', '--', remote_host, remote_command)
        p = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)

        bremote_filename = remote_filename.encode('utf-8')
        bhashname = hashname.encode('utf-8')
        io = IOCounter(p.stdout, p.stdin)

        io.write(struct.pack('<QQQQ', size, blocksize, len(bremote_filename), len(bhashname)))
        io.write(bremote_filename)
        io.write(bhashname)

        sanity_digest = hashlib.new(hashname, bremote_filename).digest()
        remote_digest = io.read(len(sanity_digest))
        if remote_digest != sanity_digest:
            raise RuntimeError('Remote script failed to execute properly')
            
        io.write(b'go')

        (remote_size,) = struct.unpack('<Q', io.read(8))
        print('Detected {} bytes'.format(remote_size))
        if remote_size < size:
            raise RuntimeError('Remote size less than local (local: %i, remote: %i)' % (size, remote_size))
        f.truncate(remote_size)
        
        # Calculate number of blocks, including the last block which may be smaller
        blockcount = int((remote_size + blocksize - 1) / blocksize)

        for i in range(blockcount):
            f.seek(i * blocksize)
            block = f.read(blocksize)
            local_digest = hashlib.new(hashname, block).digest()
            header = io.read(1)
            if header != b'd':
                raise RuntimeError("Not a digest: {!r}".format(header))
            remote_digest = io.read(hash_total.digest_size)
            if remote_digest != local_digest:
                print('X', end='')
                sys.stdout.flush()
                io.write(b'send')
                header = io.read(1)
                if header != b'b':
                    raise RuntimeError("Not a block: %s" % header)
                block = io.read(blocksize)
                hash_total.update(block)
                remote_total = io.read(hash_total.digest_size)
                if remote_total != hash_total.digest():
                    print(i, blockcount)
                    raise RuntimeError("Total checksum mismatch")
                f.seek(i * blocksize)
                f.write(block)
            else:
                print('.', end='')
                sys.stdout.flush()
                io.write(b'done')
                hash_total.update(block)
        header = io.read(1)
        if header != b't':
            raise RuntimeError("Not a total digest: %s" % header)
        remote_digest_total = io.read()
        p.stdin.close()
        p.wait()
        if remote_digest_total != hash_total.digest():
            raise RuntimeError('Checksum mismatch after transfer')
    return (io.in_total, io.out_total, remote_size)

if __name__ == '__main__':
    try:
        local_filename = sys.argv[1]
        (remote_host, remote_filename) = sys.argv[2].split(':')
        if len(sys.argv) >= 4:
            blocksize = int(sys.argv[3])
        else:
            blocksize = 64 * 1024
        if len(sys.argv) >= 5:
            hashname = sys.argv[4]
        else:
            hashname = 'sha1'
        assert len(sys.argv) <= 5
    except:
        usage = 'bscp DEST HOST:SRC [BLOCKSIZE] [HASH]'
        sys.stderr.write('Usage:\n\n    %s\n\n' % (usage,))
        sys.exit(1)
    (in_total, out_total, size) = bscp(local_filename, remote_host, remote_filename, blocksize, hashname)
    speedup = size * 1.0 / (in_total + out_total)
    sys.stderr.write('\nin=%i out=%i size=%i speedup=%.2f\n' % (in_total, out_total, size, speedup))
